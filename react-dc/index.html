<!-- vim: set colorcolumn=40: -->
<!DOCTYPE html>
<html><head><title>40x12</title>
<meta charset='utf-8'><script src='highlight.pack.js'></script>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' />
<link href='https://fonts.googleapis.com/css?family=Inconsolata:400,700' rel='stylesheet' type='text/css'>
<link href='40x12.css' rel='stylesheet' type='text/css' />
<body>
<div id='mask'>
<div id='unmask'>
<pre>
----------------------------------------

   hi!
             'codename'
          <em>'Mapbox GL Online'</em>
            Mapbox / @tmcw

    a pretty big react app
    (also uses flux, etc)

----------------------------------------

 <em>STACK</em>

 * React
 * Flux
 * React-router
 * Immutable.js
 * Written in ES6 w/ 6to5

----------------------------------------

 <em>STATS</em>

 * ~5 elite designvelopers
 * 65 components
 * 217 test assertions
 * 20 dependencies
 * 4 months in

----------------------------------------

 <em>BACKGROUND</em>

 * JavaScript shop front &amp; back
 * Backbone, jQuery, _ templates
 * d3 for HTML
 * Already taken the immutable leap
 * Never transpiled / cross-compiled

----------------------------------------

 <em>REACT</em> is pretty good

- Only found one bug in React core
- Avoiding shouldComponentUpdate
- Tracebacks can be a little weak
- Library size is a concern
- React versions across deps sucks

----------------------------------------

   Obligatory React Question

        <strong>STATE VS PROPS</strong>

- Props: control from elsewhere
- State: temporary internal self-control


----------------------------------------

 <em>IMMUTABLE</em> the only way to undo/redo

```js newVersion(stylesheet =>
      stylesheet.update(foo => 'bar'))```

 actions create versions on a stack,
 never changing data in-place

----------------------------------------

 <em>TEMPLATES</em> have always sucked

 d3 was the first step for our template
 avoidance.

 <em>Dynamic pages should be updated
 the same way they're bootstrapped</em>

----------------------------------------

 <em>ES6</em> eases the pain of writing
 functional JavaScript

```js var flip = (name) => (query) =>
  xtend({}, query, {
    [name]:
      (query[name] === '0') ? 1 : 0 })```

----------------------------------------

 <em>USE</em>   Arrow functions
       Template strings
       Object syntax

 <em>AVOID</em> List comprehensions
       Data structures
       Async syntax

----------------------------------------

  Avoiding Bugs

  - propTypes <em>always</em>
  - Pause on Caught Exceptions
  - Sentry
  - JSHint
  - TBD: Flow annotations

----------------------------------------

  <em>TESTS</em> tape + karma-tap

  Jest is cool but
  - Jasmine + async = :(
  - Doesn't test cross-browser bugs
  - Won't work with WebGL
  - Slow in our testing

----------------------------------------

  <em>FLUX</em>

  We use the Facebook flux module.
  Reflux mostly saves typing

    typing is not the problem


----------------------------------------




  (pain points)




----------------------------------------

  <em>ASYNC</em>

  NOBODY has solved async. There is no
  example to follow, no good
  documentation. Not a problem of
  syntax, but of structure.


----------------------------------------

  <em>PROBLEMS WITH ASYNC</em>

  * Async &amp; routing are app-wide
    concerns for which bad solutions
    affect all parts of your software
  * Async is the one thing you will
    always need to mock in your tests

----------------------------------------

  <em>OUR APPROACH</em>

  * Async <em>in actions only</em>
  * Some actions return Promises
  * We wait for async in react-router
  * All AJAX is in one utility module.


----------------------------------------

  <em>DRAWBACKS</em>

- Promises fail quietly: nothing should
  ever fail quietly.
- Async is tied into routing
- Who knows if this is <em>the way</em>
  to do this: async is under-documented
  and under-shared.
----------------------------------------

  <em>TRANSITIONS</em>

  Transitions on the internet are
  rotten to the core. You can get
  either control or performance
  but never stability.


----------------------------------------

  <em>ES6 bleeding-edges</em>

  Use use 6to5, which is better
  than traceur, but toolchains suck:
  source maps, jshint, tests,
  node compatibility.
  Bleeding edge = bleeding edge.

----------------------------------------
</pre>
</div>
</div>
<script src='shorthand.js'></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
